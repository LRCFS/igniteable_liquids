---
title: "Medium Petroleum Distillates"
author: "Chris Cole"
date: "19/03/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(reshape2)
library(ggplot2)
```

## Read Data

Read in the data from the original Excel spreadsheet and reformat the data to
be more usable down the line.

Starting with only B & Q White Spirit.

```{r data}
# Read first spreadsheet in Excel file - need to use edited one.
dat = read_excel('dat/ALL MPD DATA MATRIX edit.xlsx', sheet = 'BnQ WS', n_max=74, skip=1)

# function to label and melt the data. 
# Optionally normalise relative to internal standard
mungeData = function(x, name='Data', norm=FALSE) {
  if (norm) {
    # internal standard is the first peak
    its = as.vector(unlist(x[1,]))
    # normalise all peaks to their internal standard
    x = x / rep(its, each=nrow(x))
  }
  # explicitly label the retention times
  # as a column - needed by melt
  names(x) = c('R1','R2','R3')
  x = cbind(RT = rownames(x), x)
  # melt the data
  x.m = melt(x, id.vars = c('RT'), value.name = 'Area')
  # add a name 
  x.m = cbind(x.m, Sample = rep(name, nrow(x.m)))
  return(x.m)
}

# multiple datasets are on the same sheet
# extract them as independent sets

# ensure RT are in the right order for factor
# and reduce precision to 2 d.p.
RTnames = factor(round(dat$RT..4, digits=2), levels=sort(round(as.numeric(dat$RT..4), digits=2)))

# extract data from spreadsheet and label appropriately
weathered = c('Neat','10', '25', '50', '75', '90', '95')
col = 5
all.dat = data.frame()
for (w in weathered) {
  # read triplicate readings for set of RTs
  samp = data.frame(row.names = RTnames, dat[,col], dat[,col+2], dat[,col+4])
  print(head(samp))
  # process data and label
  samp.m = mungeData(samp, name = sprintf("%spc", w))
  if (nrow(all.dat) == 0) {
    # if first iteration, just assign the data
    # otherwise...
    all.dat = samp.m
  } else {
    # ...append to the bottom of the data.frame
    all.dat = rbind(all.dat, samp.m)
  }
  # increment column index
  col = col + 7
}

# fix ordering of RT factor
all.dat$RT = factor(all.dat$RT, levels=sort(as.numeric(levels(all.dat$RT))))


```


```{r plot, fig.height=7}

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

ggplot(all.dat, aes(x=RT, y=Area, colour=Sample)) + 
  geom_point() + 
  scale_colour_manual(values = cbbPalette) +
  coord_flip()

```

```{r summarise}

summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
    library(plyr)

    # New version of length which can handle NA's: if na.rm==T, don't count them
    length2 <- function (x, na.rm=FALSE) {
        if (na.rm) sum(!is.na(x))
        else       length(x)
    }

    # This does the summary. For each group's data frame, return a vector with
    # N, mean, and sd
    datac <- ddply(data, groupvars, .drop=.drop,
      .fun = function(xx, col) {
        c(N    = length2(xx[[col]], na.rm=na.rm),
          mean = mean   (xx[[col]], na.rm=na.rm),
          sd   = sd     (xx[[col]], na.rm=na.rm)
        )
      },
      measurevar
    )

    # Rename the "mean" column    
    datac <- rename(datac, c("mean" = measurevar))

    datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean

    # Confidence interval multiplier for standard error
    # Calculate t-statistic for confidence interval: 
    # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
    ciMult <- qt(conf.interval/2 + .5, datac$N-1)
    datac$ci <- datac$se * ciMult

    return(datac)
}

all.se = summarySE(all.dat, measurevar = "Area", groupvars = c('Sample','RT'))
head(all.se)

```

```{r summplot, fig.width=9}

ggplot(all.se, aes(x=RT, y=Area, colour=Sample)) +
  geom_errorbar(aes(ymin=Area-se, ymax=Area+se), width=.1) +
  #geom_line() 
  geom_point() +
  scale_colour_manual(values = cbbPalette) +
  #coord_flip() +
  #facet_grid(. ~ Sample)
  theme(axis.text.x = element_text(angle=90))


```

```{r varplot}

# 'unmelt' the data
# recast with RT rows and variable+Sample columns
all.cast = dcast(all.dat, RT~variable+Sample, value.var ="Area")
rownames(all.cast) = all.cast$RT
all.cast = all.cast[, -1]
# calc variance for each RT peak
all.var = apply(all.cast, 1, var, na.rm = TRUE)
all.var = data.frame(RT = names(all.var), Variance = all.var)
all.var$RT = factor(all.var$RT, levels=sort(as.numeric(levels(all.var$RT))))

# plot
ggplot(all.var, aes(x=RT, y=Variance)) + 
  geom_point() + 
  theme(axis.text.x = element_text(angle = 90)) +
  ggtitle("Peak Area Variance")


```